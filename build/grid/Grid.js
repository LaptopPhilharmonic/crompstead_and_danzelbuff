"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Grid = exports.GridSquare = exports.GridId = void 0;
const typescript_helpers_js_1 = require("../util/typescript-helpers.js");
const import_manager_js_1 = require("../import-manager.js");
/** For managing data for grid-based game logic */
let nextGridId = 1;
const allGrids = {};
class GridId {
    constructor() {
        this.number = nextGridId;
        nextGridId += 1;
    }
}
exports.GridId = GridId;
class GridSquare {
    constructor(grid, x, y, walkable) {
        this.thingIds = [];
        this.gridId = grid.id;
        this.x = x;
        this.y = y;
        this.walkable = walkable;
        this.interactionKey = '';
        this.walkoverKey = '';
    }
    get parentGrid() {
        const parent = Grid.byId(this.gridId);
        if (!parent) {
            throw new Error('No parent Grid found for this GridSquare. How can this happen?');
        }
        return parent;
    }
    get isInteractable() {
        return this.interactionKey !== '';
    }
    get hasWalkover() {
        return this.walkoverKey !== '';
    }
    get things() {
        return (0, typescript_helpers_js_1.filterDefinitely)(this.thingIds.map((id) => import_manager_js_1.Thing.byId(id)));
    }
    /** Add a Thing to this square (if it isn't there already) */
    addThing(thing) {
        const id = thing instanceof import_manager_js_1.Thing ? thing.id : thing;
        if (!this.thingIds.includes(id)) {
            this.thingIds.push(id);
        }
    }
    /** Remove a Thing from this square if it's there */
    removeThing(thing) {
        const id = thing instanceof import_manager_js_1.Thing ? thing.id : thing;
        const thingIndex = this.thingIds.indexOf(id);
        if (thingIndex > -1) {
            this.thingIds.splice(thingIndex, 1);
        }
    }
    /** Get another square in this grid relative to this square. Negative numbers for up and left, positive for down and right */
    getRelativeNeighbour(relativeX, relativeY) {
        return this.parentGrid.getSquare(this.x + relativeX, this.y + relativeY);
    }
    getNeighbourAbove() {
        return this.getRelativeNeighbour(0, -1);
    }
    getNeighbourToRight() {
        return this.getRelativeNeighbour(1, 0);
    }
    getNeighbourBelow() {
        return this.getRelativeNeighbour(1, 0);
    }
    getNeighbourToLeft() {
        return this.getRelativeNeighbour(0, -1);
    }
}
exports.GridSquare = GridSquare;
class Grid {
    /** Pass it an array of strings like this:
     * 'XXX'
     * 'X-X'
     * 'XXX'
     * For quick auto-population of no-go squares
     *
     * X = No-go
     * - = Walkable
     *
     * Grid slots can contain an interactive element which you can supply as you like, and
     * you can edit the walkability of individual squares later on
    */
    constructor(basicLayout) {
        this.squaresArray = [];
        if (basicLayout.length === 0 || !basicLayout.every((row) => row.length === basicLayout[0].length)) {
            throw new Error('The grid should have at least one row, and all rows should be of the same length');
        }
        this.id = new GridId();
        this.width = basicLayout[0].length;
        this.height = basicLayout.length;
        this.squares = {};
        basicLayout.forEach((row, rowIndex) => {
            row.split('').forEach((column, columnIndex) => {
                const square = new GridSquare(this, columnIndex, rowIndex, column.toUpperCase() !== 'X');
                this.squares[`${columnIndex}-${rowIndex}`] = square;
                this.squaresArray.push(square);
            });
        });
        allGrids[this.id.number] = this;
    }
    getSquare(x, y) {
        return this.squares[`${x}-${y}`];
    }
    /** Remove a thing from all squares in this grid */
    removeThing(thing) {
        this.squaresArray.forEach((square) => square.removeThing(thing));
    }
    static byId(id) {
        return allGrids[id.number];
    }
}
exports.Grid = Grid;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2dyaWQvR3JpZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5RUFBd0U7QUFDeEUsNERBQXNEO0FBRXRELGtEQUFrRDtBQUVsRCxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDbkIsTUFBTSxRQUFRLEdBQTBCLEVBQUUsQ0FBQztBQUUzQyxNQUFhLE1BQU07SUFHZjtRQUNJLElBQUksQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDO1FBQ3pCLFVBQVUsSUFBSSxDQUFDLENBQUM7SUFDcEIsQ0FBQztDQUNKO0FBUEQsd0JBT0M7QUFFRCxNQUFhLFVBQVU7SUFTbkIsWUFBWSxJQUFVLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxRQUFpQjtRQUZ2RCxhQUFRLEdBQWMsRUFBRSxDQUFDO1FBRzdCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVELElBQUksVUFBVTtRQUNWLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLGdFQUFnRSxDQUFDLENBQUM7U0FDckY7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQsSUFBSSxjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUMsY0FBYyxLQUFLLEVBQUUsQ0FBQztJQUN0QyxDQUFDO0lBRUQsSUFBSSxX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QUU7WUFDbEMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFFLEVBQUU7Z0JBQzFDLE1BQU0sTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQztnQkFDekYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLFdBQVcsSUFBSSxRQUFRLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztnQkFDcEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDbkMsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQztJQUNwQyxDQUFDO0lBRUQsU0FBUyxDQUFDLENBQVMsRUFBRSxDQUFTO1FBQzFCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxtREFBbUQ7SUFDbkQsV0FBVyxDQUFDLEtBQXNCO1FBQzlCLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBVTtRQUNsQixPQUFPLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDL0IsQ0FBQztDQUNKO0FBcERELG9CQW9EQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1heWJlLCBmaWx0ZXJEZWZpbml0ZWx5IH0gZnJvbSAnLi4vdXRpbC90eXBlc2NyaXB0LWhlbHBlcnMuanMnO1xyXG5pbXBvcnQgeyBUaGluZ0lELCBUaGluZyB9IGZyb20gJy4uL2ltcG9ydC1tYW5hZ2VyLmpzJztcclxuXHJcbi8qKiBGb3IgbWFuYWdpbmcgZGF0YSBmb3IgZ3JpZC1iYXNlZCBnYW1lIGxvZ2ljICovXHJcblxyXG5sZXQgbmV4dEdyaWRJZCA9IDE7XHJcbmNvbnN0IGFsbEdyaWRzOiB7W2tleTogbnVtYmVyXTogR3JpZH0gPSB7fTtcclxuXHJcbmV4cG9ydCBjbGFzcyBHcmlkSWQge1xyXG4gICAgbnVtYmVyOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5udW1iZXIgPSBuZXh0R3JpZElkO1xyXG4gICAgICAgIG5leHRHcmlkSWQgKz0gMTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdyaWRTcXVhcmUge1xyXG4gICAgcHJpdmF0ZSBncmlkSWQ6IEdyaWRJZDtcclxuICAgIHg6IG51bWJlcjtcclxuICAgIHk6IG51bWJlcjtcclxuICAgIHdhbGthYmxlOiBib29sZWFuO1xyXG4gICAgaW50ZXJhY3Rpb25LZXk6IHN0cmluZztcclxuICAgIHdhbGtvdmVyS2V5OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHRoaW5nSWRzOiBUaGluZ0lEW10gPSBbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihncmlkOiBHcmlkLCB4OiBudW1iZXIsIHk6IG51bWJlciwgd2Fsa2FibGU6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLmdyaWRJZCA9IGdyaWQuaWQ7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2Fsa2FibGUgPSB3YWxrYWJsZTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uS2V5ID0gJyc7XHJcbiAgICAgICAgdGhpcy53YWxrb3ZlcktleSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBwYXJlbnRHcmlkKCk6IEdyaWQge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IEdyaWQuYnlJZCh0aGlzLmdyaWRJZCk7XHJcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJlbnQgR3JpZCBmb3VuZCBmb3IgdGhpcyBHcmlkU3F1YXJlLiBIb3cgY2FuIHRoaXMgaGFwcGVuPycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBpc0ludGVyYWN0YWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmFjdGlvbktleSAhPT0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGhhc1dhbGtvdmVyKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndhbGtvdmVyS2V5ICE9PSAnJztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdGhpbmdzKCk6IFRoaW5nW10ge1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJEZWZpbml0ZWx5KHRoaXMudGhpbmdJZHMubWFwKChpZCkgPT4gVGhpbmcuYnlJZChpZCkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQWRkIGEgVGhpbmcgdG8gdGhpcyBzcXVhcmUgKGlmIGl0IGlzbid0IHRoZXJlIGFscmVhZHkpICovXHJcbiAgICBhZGRUaGluZyh0aGluZzogVGhpbmcgfCBUaGluZ0lEKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSB0aGluZyBpbnN0YW5jZW9mIFRoaW5nID8gdGhpbmcuaWQgOiB0aGluZztcclxuICAgICAgICBpZiAoIXRoaXMudGhpbmdJZHMuaW5jbHVkZXMoaWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhpbmdJZHMucHVzaChpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZW1vdmUgYSBUaGluZyBmcm9tIHRoaXMgc3F1YXJlIGlmIGl0J3MgdGhlcmUgKi9cclxuICAgIHJlbW92ZVRoaW5nKHRoaW5nOiBUaGluZyB8IFRoaW5nSUQpIHtcclxuICAgICAgICBjb25zdCBpZCA9IHRoaW5nIGluc3RhbmNlb2YgVGhpbmcgPyB0aGluZy5pZCA6IHRoaW5nO1xyXG4gICAgICAgIGNvbnN0IHRoaW5nSW5kZXggPSB0aGlzLnRoaW5nSWRzLmluZGV4T2YoaWQpO1xyXG4gICAgICAgIGlmICh0aGluZ0luZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy50aGluZ0lkcy5zcGxpY2UodGhpbmdJbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgYW5vdGhlciBzcXVhcmUgaW4gdGhpcyBncmlkIHJlbGF0aXZlIHRvIHRoaXMgc3F1YXJlLiBOZWdhdGl2ZSBudW1iZXJzIGZvciB1cCBhbmQgbGVmdCwgcG9zaXRpdmUgZm9yIGRvd24gYW5kIHJpZ2h0ICovXHJcbiAgICBnZXRSZWxhdGl2ZU5laWdoYm91cihyZWxhdGl2ZVg6IG51bWJlciwgcmVsYXRpdmVZOiBudW1iZXIpOiBNYXliZTxHcmlkU3F1YXJlPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50R3JpZC5nZXRTcXVhcmUodGhpcy54ICsgcmVsYXRpdmVYLCB0aGlzLnkgKyByZWxhdGl2ZVkpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5laWdoYm91ckFib3ZlKCk6IE1heWJlPEdyaWRTcXVhcmU+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWxhdGl2ZU5laWdoYm91cigwLCAtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TmVpZ2hib3VyVG9SaWdodCgpOiBNYXliZTxHcmlkU3F1YXJlPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVsYXRpdmVOZWlnaGJvdXIoMSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TmVpZ2hib3VyQmVsb3coKTogTWF5YmU8R3JpZFNxdWFyZT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbGF0aXZlTmVpZ2hib3VyKDEsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5laWdoYm91clRvTGVmdCgpOiBNYXliZTxHcmlkU3F1YXJlPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVsYXRpdmVOZWlnaGJvdXIoMCwgLTEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR3JpZCB7XHJcbiAgICBpZDogR3JpZElkO1xyXG4gICAgd2lkdGg6IG51bWJlcjtcclxuICAgIGhlaWdodDogbnVtYmVyO1xyXG4gICAgc3F1YXJlczoge1trZXk6IHN0cmluZ106IEdyaWRTcXVhcmV9O1xyXG4gICAgcHJpdmF0ZSBzcXVhcmVzQXJyYXk6IEdyaWRTcXVhcmVbXSA9IFtdO1xyXG5cclxuICAgIC8qKiBQYXNzIGl0IGFuIGFycmF5IG9mIHN0cmluZ3MgbGlrZSB0aGlzOiBcclxuICAgICAqICdYWFgnXHJcbiAgICAgKiAnWC1YJ1xyXG4gICAgICogJ1hYWCdcclxuICAgICAqIEZvciBxdWljayBhdXRvLXBvcHVsYXRpb24gb2Ygbm8tZ28gc3F1YXJlc1xyXG4gICAgICogXHJcbiAgICAgKiBYID0gTm8tZ29cclxuICAgICAqIC0gPSBXYWxrYWJsZVxyXG4gICAgICogXHJcbiAgICAgKiBHcmlkIHNsb3RzIGNhbiBjb250YWluIGFuIGludGVyYWN0aXZlIGVsZW1lbnQgd2hpY2ggeW91IGNhbiBzdXBwbHkgYXMgeW91IGxpa2UsIGFuZFxyXG4gICAgICogeW91IGNhbiBlZGl0IHRoZSB3YWxrYWJpbGl0eSBvZiBpbmRpdmlkdWFsIHNxdWFyZXMgbGF0ZXIgb25cclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihiYXNpY0xheW91dDogc3RyaW5nW10pIHtcclxuICAgICAgICBpZiAoYmFzaWNMYXlvdXQubGVuZ3RoID09PSAwIHx8ICFiYXNpY0xheW91dC5ldmVyeSgocm93KSA9PiByb3cubGVuZ3RoID09PSBiYXNpY0xheW91dFswXS5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdyaWQgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIHJvdywgYW5kIGFsbCByb3dzIHNob3VsZCBiZSBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBuZXcgR3JpZElkKCk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGJhc2ljTGF5b3V0WzBdLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGJhc2ljTGF5b3V0Lmxlbmd0aDtcclxuICAgICAgICB0aGlzLnNxdWFyZXMgPSB7fTtcclxuXHJcbiAgICAgICAgYmFzaWNMYXlvdXQuZm9yRWFjaCgocm93LCByb3dJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICByb3cuc3BsaXQoJycpLmZvckVhY2goKGNvbHVtbiwgY29sdW1uSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZSA9IG5ldyBHcmlkU3F1YXJlKHRoaXMsIGNvbHVtbkluZGV4LCByb3dJbmRleCwgY29sdW1uLnRvVXBwZXJDYXNlKCkgIT09ICdYJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNxdWFyZXNbYCR7Y29sdW1uSW5kZXh9LSR7cm93SW5kZXh9YF0gPSBzcXVhcmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNxdWFyZXNBcnJheS5wdXNoKHNxdWFyZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhbGxHcmlkc1t0aGlzLmlkLm51bWJlcl0gPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNxdWFyZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IE1heWJlPEdyaWRTcXVhcmU+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zcXVhcmVzW2Ake3h9LSR7eX1gXTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVtb3ZlIGEgdGhpbmcgZnJvbSBhbGwgc3F1YXJlcyBpbiB0aGlzIGdyaWQgKi9cclxuICAgIHJlbW92ZVRoaW5nKHRoaW5nOiBUaGluZyB8IFRoaW5nSUQpIHtcclxuICAgICAgICB0aGlzLnNxdWFyZXNBcnJheS5mb3JFYWNoKChzcXVhcmUpID0+IHNxdWFyZS5yZW1vdmVUaGluZyh0aGluZykpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBieUlkKGlkOiBHcmlkSWQpOiBNYXliZTxHcmlkPiB7XHJcbiAgICAgICAgcmV0dXJuIGFsbEdyaWRzW2lkLm51bWJlcl07XHJcbiAgICB9XHJcbn0iXX0=