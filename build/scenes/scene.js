"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scene = exports.SceneID = void 0;
const import_manager_js_1 = require("../import-manager.js");
let nextId = 1;
/** All RenderNodes live here for lookup */
const allScenes = {};
class SceneID {
    constructor() {
        this.number = nextId;
        nextId += 1;
    }
}
exports.SceneID = SceneID;
class Scene {
    constructor(data) {
        this.id = new SceneID();
        this.w = data.w;
        this.h = data.h;
        this.renderNodeIDs = [];
        allScenes[this.id.number] = this;
    }
    get renderNodes() {
        return this.renderNodeIDs.map((id) => import_manager_js_1.RenderNode.byId(id)).filter((node) => node !== null);
    }
    /** Adds a render node, and returns that node for reference. Unless it doesn't exist - it'll throw an error then. */
    addRenderNode(node) {
        if (!this.isParentOf(node)) {
            node.detach();
            this.renderNodeIDs.push(node.id);
            node.scene = this;
        }
        return node;
    }
    addRenderNodes(nodes) {
        nodes.forEach((node) => this.addRenderNode(node));
    }
    isParentOf(node) {
        return !!this.renderNodeIDs.find((id) => id.number === node.id.number);
    }
    /** Removes the ID of the RenderNode from this Scene, but does not delete the RenderNode itself */
    removeRenderNode(node) {
        const index = this.renderNodeIDs.findIndex((n) => n.number === node.id.number);
        if (index > -1) {
            this.renderNodeIDs.splice(index, 1);
        }
        node.scene = null;
    }
    /** Removes the IDs of the RenderNodes from this Scene, but does not delete the RenderNodes themselves */
    removeRenderNodes(nodes) {
        nodes.forEach((n) => this.removeRenderNode(n));
    }
    static byId(id) {
        return id ? allScenes[id.number] : null;
    }
}
exports.Scene = Scene;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NlbmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zY2VuZXMvU2NlbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNERBQWdFO0FBR2hFLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztBQUVmLDJDQUEyQztBQUMzQyxNQUFNLFNBQVMsR0FBMkIsRUFBRSxDQUFDO0FBRTdDLE1BQWEsT0FBTztJQUdoQjtRQUNJLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLE1BQU0sSUFBSSxDQUFDLENBQUM7SUFDaEIsQ0FBQztDQUNKO0FBUEQsMEJBT0M7QUFPRCxNQUFhLEtBQUs7SUFNZCxZQUFZLElBQWU7UUFDdkIsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNoQixJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDaEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7UUFFeEIsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ3JDLENBQUM7SUFFRCxJQUFJLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyw4QkFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBaUIsQ0FBQztJQUMvRyxDQUFDO0lBRUQsb0hBQW9IO0lBQ3BILGFBQWEsQ0FBQyxJQUFnQjtRQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDZCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDakMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7U0FDckI7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsY0FBYyxDQUFDLEtBQW1CO1FBQzlCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQsVUFBVSxDQUFDLElBQWdCO1FBQ3ZCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVELGtHQUFrRztJQUNsRyxnQkFBZ0IsQ0FBQyxJQUFnQjtRQUM3QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQy9FLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQ1osSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3ZDO1FBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDdEIsQ0FBQztJQUVELHlHQUF5RztJQUN6RyxpQkFBaUIsQ0FBQyxLQUFtQjtRQUNqQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFrQjtRQUMxQixPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQzVDLENBQUM7Q0FDSjtBQXRERCxzQkFzREMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZW5kZXJOb2RlLCBSZW5kZXJOb2RlSUQgfSBmcm9tICcuLi9pbXBvcnQtbWFuYWdlci5qcyc7XHJcbmltcG9ydCB7IE1heWJlIH0gZnJvbSAnLi4vdXRpbC90eXBlc2NyaXB0LWhlbHBlcnMuanMnO1xyXG5cclxubGV0IG5leHRJZCA9IDE7XHJcblxyXG4vKiogQWxsIFJlbmRlck5vZGVzIGxpdmUgaGVyZSBmb3IgbG9va3VwICovXHJcbmNvbnN0IGFsbFNjZW5lczoge1trZXk6IG51bWJlcl06IFNjZW5lfSA9IHt9O1xyXG5cclxuZXhwb3J0IGNsYXNzIFNjZW5lSUQge1xyXG4gICAgbnVtYmVyOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5udW1iZXIgPSBuZXh0SWQ7XHJcbiAgICAgICAgbmV4dElkICs9IDE7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNjZW5lRGF0YSA9IHtcclxuICAgIHc6IG51bWJlcjtcclxuICAgIGg6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNjZW5lIHtcclxuICAgIGlkOiBTY2VuZUlEO1xyXG4gICAgdzogbnVtYmVyO1xyXG4gICAgaDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSByZW5kZXJOb2RlSURzOiBSZW5kZXJOb2RlSURbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhOiBTY2VuZURhdGEpIHtcclxuICAgICAgICB0aGlzLmlkID0gbmV3IFNjZW5lSUQoKTtcclxuICAgICAgICB0aGlzLncgPSBkYXRhLnc7XHJcbiAgICAgICAgdGhpcy5oID0gZGF0YS5oO1xyXG4gICAgICAgIHRoaXMucmVuZGVyTm9kZUlEcyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGFsbFNjZW5lc1t0aGlzLmlkLm51bWJlcl0gPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCByZW5kZXJOb2RlcygpOiBSZW5kZXJOb2RlW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlck5vZGVJRHMubWFwKChpZCkgPT4gUmVuZGVyTm9kZS5ieUlkKGlkKSkuZmlsdGVyKChub2RlKSA9PiBub2RlICE9PSBudWxsKSBhcyBSZW5kZXJOb2RlW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEFkZHMgYSByZW5kZXIgbm9kZSwgYW5kIHJldHVybnMgdGhhdCBub2RlIGZvciByZWZlcmVuY2UuIFVubGVzcyBpdCBkb2Vzbid0IGV4aXN0IC0gaXQnbGwgdGhyb3cgYW4gZXJyb3IgdGhlbi4gKi9cclxuICAgIGFkZFJlbmRlck5vZGUobm9kZTogUmVuZGVyTm9kZSk6IFJlbmRlck5vZGUge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1BhcmVudE9mKG5vZGUpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuZGV0YWNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZUlEcy5wdXNoKG5vZGUuaWQpO1xyXG4gICAgICAgICAgICBub2RlLnNjZW5lID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkUmVuZGVyTm9kZXMobm9kZXM6IFJlbmRlck5vZGVbXSkge1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHRoaXMuYWRkUmVuZGVyTm9kZShub2RlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQYXJlbnRPZihub2RlOiBSZW5kZXJOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZW5kZXJOb2RlSURzLmZpbmQoKGlkKSA9PiBpZC5udW1iZXIgPT09IG5vZGUuaWQubnVtYmVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVtb3ZlcyB0aGUgSUQgb2YgdGhlIFJlbmRlck5vZGUgZnJvbSB0aGlzIFNjZW5lLCBidXQgZG9lcyBub3QgZGVsZXRlIHRoZSBSZW5kZXJOb2RlIGl0c2VsZiAqL1xyXG4gICAgcmVtb3ZlUmVuZGVyTm9kZShub2RlOiBSZW5kZXJOb2RlKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnJlbmRlck5vZGVJRHMuZmluZEluZGV4KChuKSA9PiBuLm51bWJlciA9PT0gbm9kZS5pZC5udW1iZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZUlEcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLnNjZW5lID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVtb3ZlcyB0aGUgSURzIG9mIHRoZSBSZW5kZXJOb2RlcyBmcm9tIHRoaXMgU2NlbmUsIGJ1dCBkb2VzIG5vdCBkZWxldGUgdGhlIFJlbmRlck5vZGVzIHRoZW1zZWx2ZXMgKi9cclxuICAgIHJlbW92ZVJlbmRlck5vZGVzKG5vZGVzOiBSZW5kZXJOb2RlW10pIHtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKChuKSA9PiB0aGlzLnJlbW92ZVJlbmRlck5vZGUobikpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBieUlkKGlkOiBNYXliZTxTY2VuZUlEPik6IE1heWJlPFNjZW5lPiB7XHJcbiAgICAgICAgcmV0dXJuIGlkID8gYWxsU2NlbmVzW2lkLm51bWJlcl0gOiBudWxsO1xyXG4gICAgfVxyXG59Il19